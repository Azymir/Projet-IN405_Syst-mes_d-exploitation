#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <pthread.h>

#include "mes_types.h"
#include "banque.h"

#include "deck.h"

pthread_cond_t condition = PTHREAD_COND_INITIALIZER;
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;

int nextLine(int Fichier, int i)
{

	char caractere = 0;
	for (int j = 0; j < i; j++) {

		while (caractere != '#') {

			read(Fichier, &caractere, 1);

		}

		caractere = 0;

	}

	if (i > 0) {

		write(Fichier, "\n", 1);

	}

	return Fichier;

}

char takeCard(deck_t * Deck)
{
	shuffleDeck(Deck);
	cardvalue_t cdv = getValueFromCardID(drawCard(Deck));
	discardCard(Deck, cdv);

	if (cdv == VA) {

		return 'A';
	} else if (cdv == V2) {

		return '2';
	} else if (cdv == V3) {

		return '3';
	} else if (cdv == V4) {

		return '4';
	} else if (cdv == V5) {

		return '5';
	} else if (cdv == V6) {

		return '6';
	} else if (cdv == V7) {

		return '7';
	} else if (cdv == V8) {

		return '8';
	} else if (cdv == V9) {

		return '9';
	} else if (cdv == VX) {

		return 'X';
	} else if (cdv == VJ) {

		return 'J';
	} else if (cdv == VQ) {

		return 'Q';
	} else if (cdv == VK) {

		return 'K';
	} else {

		return '0';

	}

}

int convert_card(char c)
{

	if (c == 'J' || c == 'K' || c == 'X' || c == 'Q') {
		return 10;
	} else if (c == 'A') {	// on ne peut pas savoir ici si on veut que l'as soit compté comme 1 ou 10

		return -1;
	}

	else
		return c - '0';	// on convertit les autres entier directement

}

int calcul_total(char *cartes)
{

	int total = 0;

	int as = 0;		// il faut s'occuper des as qui puvent valoir 10 ou 1

	for (int i = 0; i < strlen(cartes); i++) {
		if (convert_card(cartes[i]) != -1) {
			total += convert_card(cartes[i]);
		} else {
			as++;	// on compte les as qu'on a récupéré pour les traiter plus tard
		}
	}

	for (int i = 0; i < as; i++) {
		if (total < 11 && i == as - 1) {	// si il ne nous reste qu'un as et qu'on est en dessous de 12
			total += 11;
		} else if (total < 10 && i == as - 2) {	// si il nous reste 2 as
			total += 11;
		} else if (total < 9 && i == as - 3) {	// si on a beaucoup de chance et qu'on en a 3
			total += 11;
		} else if (total < 8 && i == as - 4) {	// si on a BEAAAAUCOUP de chance et qu'on en a 4
			total += 11;
		} else {
			total += 1;
		}
	}

	return total;

}

int calcul_mise(JOUEUR J, BANQUE B)
{
	int mise = 0;

	if (strcmp(B.typeMise, "50") == 0) {
		mise = 50;
	}

	else if (strcmp(B.typeMise, "200-") == 0) {
		if (J.lastGain == 0 || J.lastMise == 25) {
			mise = 200;
		} else {
			mise = J.lastMise / 2;
		}
	}

	else if (strcmp(B.typeMise, "10+") == 0) {
		if (J.lastGain == 0 || J.lastMise == 80) {
			mise = 10;
		} else {
			mise = J.lastMise * 2;
		}
	} else {

		printf
		    ("ERREUR : Le type de mise : %s  n'est pas admis, essayez 10+,200- ou 50 \n il se peut aussi que vous n'ayez pas entré suffisament de joueurs comparativement au nombre entré \n",
		     B.typeMise);
		exit(0);

	}

	return mise;

}

int calcul_gain(JOUEUR J)
{
	int gain = 0;
	if (J.total_Joueur > 21) {
		return gain;
	}

	else if (J.total_Banque > 21) {

		if (J.total_Joueur == 21 && strlen(J.cartes) == 2) {	// BLACKJACK
			gain = J.mise * 3;

		}

		else {
			gain = J.mise * 2;
		}

	}

	else if (J.total_Joueur > J.total_Banque) {
		if (J.total_Joueur == 21 && strlen(J.cartes) == 2) {	// BLACKJACK
			gain = J.mise * 3;

		}

		else {
			gain = J.mise * 2;
		}
	}

	else if (J.total_Joueur == J.total_Banque) {
		if (J.total_Joueur == 21 && strlen(J.cartes) == 2 && strlen(J.banque) > 2) {	// BLACKJACK
			gain = J.mise * 3;

		}

		else {
			gain = J.mise;
		}

	}

	else {

		return gain;
	}

	return gain;

}

int calcul_jetons(JOUEUR J)
{
	int jet = 0;

	jet = J.nbJetons - J.mise + J.gain;

	if (jet < 0) {
		jet = 0;
	}

	return jet;

}

JOUEUR calcul_all(JOUEUR J, BANQUE B)
{

	J.total_Joueur = calcul_total(J.cartes);

	J.total_Banque = calcul_total(J.banque);

	J.mise = calcul_mise(J, B);
	J.lastMise = J.mise;

	J.gain = calcul_gain(J);
	J.lastGain = J.gain;

	J.nbJetons = calcul_jetons(J);

	return J;
}

JOUEUR ecrire_joueur(JOUEUR J)
{

	char buffer[20];	// sert à convertir les entiers en string

	sprintf(buffer, "joueur%d.player", J.i + 1);
	char *nom = buffer;
	int Fichier;
	if (J.t == 0) {

		Fichier = open(nom, O_CREAT | O_RDWR, S_IRWXU | S_IRGRP | S_IWGRP);	// on lance le fichier en écriture et lecture juste pour vérifier le contenu
	} else {
		Fichier = open(nom, O_RDWR, S_IRWXU | S_IRGRP | S_IWGRP);	// on lance le fichier en écriture et lecture juste pour vérifier le contenu
	}

	Fichier = nextLine(Fichier, J.t);

	sprintf(buffer, "joueur %d", J.i + 1);
	if (J.stop) {

		printf
		    ("- Le %s n'a plus de jetons ou a atteint son objectif il ne joue plus\n\n",
		     nom);
	}

	else {

		printf("- Le %s a pioché %s, total : %d\n", nom, J.cartes,
		       J.total_Joueur);
		printf
		    ("- Sa mise était de %d, son gain est de %d il est à : %d\n\n",
		     J.mise, J.gain, J.nbJetons);
	}
	write(Fichier, J.cartes, strlen(J.cartes));	// cartes du joueur
	write(Fichier, ";", 1);

	sprintf(buffer, "%d", J.total_Joueur);

	write(Fichier, buffer, strlen(buffer));	// total du joueur
	write(Fichier, ";", 1);

	write(Fichier, J.banque, strlen(J.banque));	// cartes de la banque
	write(Fichier, ";", 1);

	sprintf(buffer, "%d", J.total_Banque);

	write(Fichier, buffer, strlen(buffer));	// total des cartes de la banque
	write(Fichier, ";", 1);

	sprintf(buffer, "%d", J.mise);

	write(Fichier, buffer, strlen(buffer));	// mise
	write(Fichier, ";", 1);

	sprintf(buffer, "%d", J.gain);

	write(Fichier, buffer, strlen(buffer));	// gain
	write(Fichier, ";", 1);

	sprintf(buffer, "%d", J.nbJetons);

	write(Fichier, buffer, strlen(buffer));	// jetons restants
	write(Fichier, "#", 1);

	close(Fichier);

	return J;

}

void *tours(void *arg)
{

	GAME *G = (GAME *) arg;

	deck_t *Deck = G->Deck;
	shuffleDeck(Deck);
	int i;

	pthread_mutex_lock(&mutex);	// on verouille le mutex pour le numéro du joueur
	pthread_cond_signal(&condition);
	i = G->joueur;
	G->joueur--;
	pthread_mutex_unlock(&mutex);

	G->J[i].total_Joueur = 0;
	memset(G->J[i].cartes, 0, sizeof(G->J[i].cartes));

	if (!G->J[i].stop) {

		while (G->J[i].total_Joueur < G->B[i].valStop) {

			G->J[i].cartes[strlen(G->J[i].cartes)] = takeCard(Deck);

			G->J[i].total_Joueur = calcul_total(G->J[i].cartes);

		}

	}

	G->J[i].t = G->tour;

	if (G->tour == 0) {

		G->J[i].lastMise = 0;
		G->J[i].lastGain = 0;
		G->J[i].nbJetons = G->B[i].nbJetons;	// seulement au premier tour

	}

	if (!G->J[i].stop) {

		G->J[i] = calcul_all(G->J[i], G->B[i]);

	}

	G->J[i].i = i;

	G->J[i] = ecrire_joueur(G->J[i]);

	if (G->J[i].nbJetons == 0 || G->J[i].nbJetons > G->B[i].objJetons - 1) {

		G->J[i].stop = 1;
	}

	sleep(3);

	G->Deck = Deck;

	return NULL;
}
